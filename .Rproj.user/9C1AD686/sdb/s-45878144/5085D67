{
    "collab_server" : "",
    "contents" : "#' @title Two-Sample t-Test Power Analysis for Proportions\n#'\n#' @description\n#' \\code{AB_t2n_prop} performs the power analysis for AB testing, and when\n#'     dependent variables are proportions (between 0 and 1). It uses the Welch t-test,\n#'     which allows for the standard deviation to vary across groups.\n#'\n#' @param prop_A Proportion of successes in group A (between 0 and 1)\n#' @param prop_B Proportion of successes in group B (between 0 and 1)\n#' @param N Total number of observations (sum of observations for groups A and B)\n#' @param percent_B Percentage of total observations allocated to group B\n#'     (between 0 and 1 - e.g. input .5 for 50\\%)\n#' @param sig_level Significance level (Type I error probability)\n#' @param power Power of test (1 minus Type II error probability)\n#' @param alternative Character string specifying the alternative hypothesis,\n#'     must be one of \"two_sided\" (default), \"greater\" or \"less\"\n#' @param max_sample Maximum sample size that is searched for\n#'\n#' @details\n#'     Exactly one of the parameters 'prop_A', 'prop_B', 'N', 'percent_B', 'sig_level',\n#'     and 'power' must be passed as NULL, and the omitted parameter is determined\n#'     from the others. The standard deviations for each group are calculated using the\n#'     formula sqrt(prop * (1 - prop)).\n#'     When 'percent_B' is the parameter omitted,\n#'     two solutions may exist, in which case the smaller value will be returned.\n#'     For two_sided tests, when 'prop_A' or 'prop_B' is omitted, two solutions may exist,\n#'     in which case both will be reported\n#'\n#' @return Object of class \"power.htest\", a list of the arguments\n#' (including the computed one).\n#'\n#' @examples\n#' # Search for power given other parameters\n#' AB_t2n_prop(prop_A = .2, prop_B = .25,\n#'            N = 3000, percent_B = .3,\n#'            sig_level = .05, alternative = 'two_sided')\n#'\n#' # Search for proportion in group B required to satisfy other parameters\n#' AB_t2n_prop(prop_A = .2, N = 3000, percent_B = .3,\n#' power = .8, sig_level = .05,\n#' alternative = 'two_sided')\nAB_t2n_prop <-\n  function (prop_A = NULL, prop_B = NULL,\n            N = NULL, percent_B = NULL,\n            sig_level = NULL, power = NULL,\n            alternative = c(\"two_sided\", \"less\", \"greater\"),\n            max_sample = 1e+07) {\n\n    ### Input Error Checking\n    if (sum(sapply(list(N, percent_B, prop_A, prop_B,\n                        power, sig_level), is.null)) != 1)\n      stop(\"Exactly one of N, percent_B, prop_A, prop_B, power, and sig_level must be NULL\")\n    if (!is.null(sig_level) && !is.numeric(sig_level) ||\n        any(sig_level < 0 | sig_level > 1))\n      stop(sQuote(\"sig_level\"), \" must be numeric in [0, 1]\")\n    if (!is.null(percent_B) && !is.numeric(percent_B) ||\n        any(percent_B < 0 | percent_B > 1))\n      stop(sQuote(\"percent_B\"), \" must be numeric in [0, 1]\")\n    if (!is.null(power) && !is.numeric(power) ||\n        any(power < 0 | power > 1))\n      stop(sQuote(\"power\"), \" must be numeric in [0, 1]\")\n    if (!is.null(N) && N < 10)\n      stop(\"Total number of observations must at least 10\")\n    if (!is.null(N) && N < 100)\n      warning(\"This package was not designed for small sample experiment planning (N < 100),\n              and the results may not be correct or optimal\")\n\n    alternative <- match.arg(alternative)\n    test_type <- switch(alternative, less = 1, two_sided = 2, greater = 3)\n\n    if (test_type == 2 && !is.null(mean_diff)){\n      mean_diff <- abs(mean_diff)\n    }\n    if (test_type == 1){\n      power_eval <- quote({\n        mean_diff = prop_B - prop_A\n        N_B <- N * percent_B\n        N_A <- N - N_B\n        sd_A = sqrt(prop_A * (1 - prop_A))\n        sd_B = sqrt(prop_B * (1 - prop_B))\n        # Welch-Satterthwaite equation\n        df_ws <- (sd_A ^ 2 / N_A + sd_B ^ 2 / N_B) ^ 2 / (\n          (sd_A ^ 2 / N_A) ^ 2 / (N_A - 1) + (sd_B ^ 2 / N_B) ^ 2 / (N_B - 1)\n        )\n        t_stat <- mean_diff / sqrt((sd_A ^ 2) / N_A + (sd_B ^ 2) / N_B)\n\n        pt(qt(sig_level, df = df_ws, lower = TRUE),\n           df = df_ws, ncp = t_stat,\n           lower = TRUE)\n      })\n    }\n    if (test_type == 2){\n      power_eval <- quote({\n        mean_diff <- abs(prop_B - prop_A)\n        N_B <- N * percent_B\n        N_A <- N - N_B\n        sd_A = sqrt(prop_A * (1 - prop_A))\n        sd_B = sqrt(prop_B * (1 - prop_B))\n        df_ws <- (sd_A ^ 2 / N_A + sd_B ^ 2 / N_B) ^ 2 / (\n          (sd_A ^ 2 / N_A) ^ 2 / (N_A - 1) + (sd_B ^ 2 / N_B) ^ 2 / (N_B - 1)\n        )\n        t_stat <- mean_diff / sqrt((sd_A ^ 2) / N_A + (sd_B ^ 2) / N_B)\n\n        qu <- qt(sig_level / 2, df= df_ws, lower = FALSE)\n        pt(qu, df = df_ws, ncp = t_stat, lower = FALSE) +\n          pt(-qu, df = df_ws, ncp = t_stat, lower = TRUE)\n      })\n    }\n    if (test_type == 3){\n      power_eval <- quote({\n        mean_diff = prop_B - prop_A\n        N_B <- N * percent_B\n        N_A <- N - N_B\n        sd_A <- sqrt(prop_A * (1 - prop_A))\n        sd_B <- sqrt(prop_B * (1 - prop_B))\n        df_ws <- (sd_A ^ 2 / N_A + sd_B ^ 2 / N_B) ^ 2 / (\n          (sd_A ^ 2 / N_A) ^ 2 / (N_A - 1) + (sd_B ^ 2 / N_B) ^ 2 / (N_B - 1)\n        )\n        t_stat <- mean_diff / sqrt((sd_A ^ 2) / N_A + (sd_B ^ 2) / N_B)\n\n        pt(qt(sig_level, df = df_ws, lower = FALSE), df = df_ws,\n           ncp = t_stat, lower = FALSE)\n      })\n    }\n\n    if (is.null(power)) {\n      power <- eval(power_eval)\n    } else if (is.null(N)) {\n      # Require each group to have at least 5 observations\n      min_N <- max((5 / percent_B), (5 / (1 - percent_B)))\n      N <- min_N\n      if (eval(power_eval) >= power){\n        warning(\"Target power achieved at lowest feasible sample size given percent_B\")\n      } else {\n        N <- uniroot(function(N) eval(power_eval) - power,\n                     c(min_N, max_sample + 1))$root\n      }\n    } else if (is.null(percent_B)) {\n      min_percent_B <- max(0.001, 10 / N)\n      search_grid <- seq(min_percent_B, 1 - min_percent_B, 0.0001)\n      length_grid <- length(search_grid)\n      diff_power <- sapply(search_grid, function(percent_B) eval(power_eval) - power)\n      percent_B <- search_grid[min(c(1:length_grid)[diff_power > 0])]\n    } else if (is.null(prop_A)) {\n      if (test_type == 1){\n        prop_A <- uniroot(function(prop_A) eval(power_eval) - power,\n                             c(prop_B, 1))$root\n      } else if (test_type == 2){\n        try({root1 <- uniroot(function(prop_A) eval(power_eval) - power,\n                          c(0, prop_B))$root}, silent = T)\n        try({root2 <- uniroot(function(prop_A) eval(power_eval) - power,\n                                 c(prop_B, 1))$root}, silent = T)\n        prop_A <- c()\n        if(exists('root1')) prop_A <- c(prop_A, root1)\n        if(exists('root2')) prop_A <- c(prop_A, root2)\n      } else if (test_type == 3){\n        prop_A <- uniroot(function(prop_A) eval(power_eval) - power,\n                             c(0, prop_B))$root\n      }\n    } else if (is.null(prop_B)) {\n      if (test_type == 1){\n        prop_B <- uniroot(function(prop_B) eval(power_eval) - power,\n                          c(0, prop_A))$root\n      } else if (test_type == 2){\n        try({root1 <- uniroot(function(prop_B) eval(power_eval) - power,\n                              c(0, prop_A))$root}, silent = T)\n        try({root2 <- uniroot(function(prop_B) eval(power_eval) - power,\n                              c(prop_A, 1))$root}, silent = T)\n        prop_B <- c()\n        if(exists('root1')) prop_B <- c(prop_B, root1)\n        if(exists('root2')) prop_B <- c(prop_B, root2)\n      } else if (test_type == 3){\n        prop_B <- uniroot(function(prop_B) eval(power_eval) - power,\n                          c(prop_A, 1))$root\n      }\n    } else if (is.null(sig_level)) {\n      sig_level <- uniroot(function(sig_level) eval(power_eval) - power,\n                           c(1e-10, 1 - 1e-10))$root\n    } else stop(\"solution not found for given parameters\")\n\n    ### Output\n    structure(list(N = N,\n                   percent_B = percent_B,\n                   prop_A = prop_A,\n                   prop_B = prop_B,\n                   mean_diff = prop_B - prop_A,\n                   sig_level = sig_level,\n                   power = power,\n                   alternative = alternative,\n                   method = \"t-test Power Calculation\"),\n                   class = \"power.htest\")\n  }\n",
    "created" : 1496612709057.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1532248686",
    "id" : "5085D67",
    "lastKnownWriteTime" : 1496618709,
    "last_content_update" : 1496618709655,
    "path" : "~/Desktop/pwrAB/R/AB_t2n_prop.R",
    "project_path" : "R/AB_t2n_prop.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}